# サーブレットフィルター（Servlet Filter）

フィルターは、サーブレットの「前後」に処理を挟む仕組みです。
全てのリクエストに共通する処理を一箇所にまとめられます。

---

## フィルターとは

```
ブラウザ
   │
   ↓ リクエスト
┌─────────────────┐
│   Filter 1      │  ← 前処理（例：文字コード設定）
└─────────────────┘
   │
   ↓
┌─────────────────┐
│   Filter 2      │  ← 前処理（例：ログイン確認）
└─────────────────┘
   │
   ↓
┌─────────────────┐
│   Servlet       │  ← 本来の処理
└─────────────────┘
   │
   ↓
┌─────────────────┐
│   Filter 2      │  ← 後処理
└─────────────────┘
   │
   ↓
┌─────────────────┐
│   Filter 1      │  ← 後処理
└─────────────────┘
   │
   ↓ レスポンス
ブラウザ
```

**例えるなら**：
- 空港のセキュリティチェック
- 入る時にチェック → 飛行機に乗る → 出る時にチェック

---

## 基本的な書き方

```java
package jp.co.recipe.filter;

import java.io.IOException;
import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.annotation.WebFilter;

@WebFilter("/*")  // どのURLに適用するか
public class MyFilter implements Filter {

    // フィルター初期化時（1回だけ）
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        System.out.println("フィルター初期化");
    }

    // リクエストごとに実行
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {

        // ===== 前処理（サーブレットの前）=====
        System.out.println("前処理");

        // 次のフィルターまたはサーブレットへ進む
        chain.doFilter(request, response);

        // ===== 後処理（サーブレットの後）=====
        System.out.println("後処理");
    }

    // フィルター破棄時（1回だけ）
    @Override
    public void destroy() {
        System.out.println("フィルター破棄");
    }
}
```

### 重要ポイント: chain.doFilter()

```java
public void doFilter(...) {

    // ここは「前処理」
    // サーブレットが実行される前に実行される

    chain.doFilter(request, response);  // ← これで次へ進む

    // ここは「後処理」
    // サーブレットが実行された後に実行される
}
```

**chain.doFilter()を呼ばないと**：
- サーブレットが実行されない
- ユーザーには何も表示されない
- 意図的にブロックしたい時に使う（認証フィルターなど）

---

## @WebFilterのURL指定

```java
@WebFilter("/*")           // 全てのURLに適用
@WebFilter("/admin/*")     // /admin/ 以下に適用
@WebFilter("/recipe/*")    // /recipe/ 以下に適用
@WebFilter("*.jsp")        // 全てのJSPに適用
@WebFilter("/login")       // /login だけに適用
```

---

## 実装例1: 文字エンコーディング

日本語の文字化けを防ぐフィルターです。

### EncodingFilter.java

```java
package jp.co.recipe.filter;

import java.io.IOException;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.annotation.WebFilter;

@WebFilter("/*")  // 全URLに適用
public class EncodingFilter implements Filter {

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        // 初期化処理（今回はいらない）
    }

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {

        // 前処理: 文字コードを設定
        request.setCharacterEncoding("UTF-8");   // リクエスト（受信）
        response.setCharacterEncoding("UTF-8");  // レスポンス（送信）

        // サーブレットへ進む
        chain.doFilter(request, response);

        // 後処理: 今回は何もしない
    }

    @Override
    public void destroy() {
    }
}
```

### なぜフィルターで書くのか？

**フィルターを使わない場合**：
```java
// 全てのサーブレットに書く必要がある（面倒！）
public class LoginServlet extends HttpServlet {
    protected void doPost(...) {
        request.setCharacterEncoding("UTF-8");  // 毎回書く
        // 処理
    }
}

public class RecipeCreateServlet extends HttpServlet {
    protected void doPost(...) {
        request.setCharacterEncoding("UTF-8");  // 毎回書く
        // 処理
    }
}
```

**フィルターを使う場合**：
```java
// フィルター1つで全サーブレットに適用される
@WebFilter("/*")
public class EncodingFilter implements Filter {
    // ここに1回書くだけでOK
}
```

---

## 実装例2: ログイン認証チェック

ログインしていないユーザーを特定のページからブロックします。

### AuthFilter.java

```java
package jp.co.recipe.filter;

import java.io.IOException;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

// /recipe/new, /recipe/edit, /recipe/delete に適用
@WebFilter(urlPatterns = {"/recipe/new", "/recipe/edit", "/recipe/delete"})
public class AuthFilter implements Filter {

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
    }

    @Override
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
            throws IOException, ServletException {

        // ServletRequest を HttpServletRequest にキャスト
        HttpServletRequest request = (HttpServletRequest) req;
        HttpServletResponse response = (HttpServletResponse) res;

        // セッションからユーザー情報を取得
        HttpSession session = request.getSession(false);

        // ログインチェック
        if (session == null || session.getAttribute("user") == null) {
            // ログインしていない → ログインページへリダイレクト
            response.sendRedirect(request.getContextPath() + "/views/jsp/login.jsp");
            return;  // ここで終了！chain.doFilter()を呼ばない
        }

        // ログインしている → サーブレットへ進む
        chain.doFilter(request, response);
    }

    @Override
    public void destroy() {
    }
}
```

### 処理の流れ

```
ログインしていない場合:
/recipe/new にアクセス
    ↓
AuthFilter: session に user がない
    ↓
login.jsp にリダイレクト（chain.doFilter()を呼ばない）
    ↓
RecipeCreateServlet は実行されない


ログインしている場合:
/recipe/new にアクセス
    ↓
AuthFilter: session に user がある
    ↓
chain.doFilter() を呼ぶ
    ↓
RecipeCreateServlet が実行される
```

---

## 実装例3: アクセスログ

誰がいつどのページにアクセスしたかをログに残します。

### AccessLogFilter.java

```java
package jp.co.recipe.filter;

import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpSession;

import jp.co.recipe.dto.UserDTO;

@WebFilter("/*")
public class AccessLogFilter implements Filter {

    private DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
    }

    @Override
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
            throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;

        // 静的ファイル（CSS、画像）はログを出さない
        String uri = request.getRequestURI();
        if (uri.endsWith(".css") || uri.endsWith(".js") || uri.endsWith(".jpg") || uri.endsWith(".png")) {
            chain.doFilter(req, res);
            return;
        }

        // ユーザー名を取得（ログインしていなければ "ゲスト"）
        String username = "ゲスト";
        HttpSession session = request.getSession(false);
        if (session != null && session.getAttribute("user") != null) {
            UserDTO user = (UserDTO) session.getAttribute("user");
            username = user.getUsername();
        }

        // ログ出力
        String time = LocalDateTime.now().format(formatter);
        String method = request.getMethod();
        System.out.println("[" + time + "] " + username + " " + method + " " + uri);

        // サーブレットへ進む
        chain.doFilter(req, res);
    }

    @Override
    public void destroy() {
    }
}
```

### 出力例

```
[2024-01-15 14:30:25] ゲスト GET /recipe/home
[2024-01-15 14:30:45] 田中さくら GET /recipe/detail?id=5
[2024-01-15 14:31:02] 田中さくら POST /recipe/new
[2024-01-15 14:31:15] 山田太郎 GET /recipe/search?keyword=カレー
```

---

## 実装例4: 処理時間の計測

ページの表示にかかった時間を計測します。

### PerformanceFilter.java

```java
package jp.co.recipe.filter;

import java.io.IOException;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletRequest;

@WebFilter("/*")
public class PerformanceFilter implements Filter {

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
    }

    @Override
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
            throws IOException, ServletException {

        HttpServletRequest request = (HttpServletRequest) req;
        String uri = request.getRequestURI();

        // 静的ファイルは計測しない
        if (uri.endsWith(".css") || uri.endsWith(".js") || uri.endsWith(".jpg")) {
            chain.doFilter(req, res);
            return;
        }

        // ===== 前処理: 開始時間を記録 =====
        long startTime = System.currentTimeMillis();

        // サーブレット実行
        chain.doFilter(req, res);

        // ===== 後処理: 経過時間を計算 =====
        long endTime = System.currentTimeMillis();
        long duration = endTime - startTime;

        // 100ms以上かかったら警告
        if (duration > 100) {
            System.out.println("[SLOW] " + uri + " : " + duration + "ms");
        } else {
            System.out.println("[OK] " + uri + " : " + duration + "ms");
        }
    }

    @Override
    public void destroy() {
    }
}
```

### 出力例

```
[OK] /recipe/home : 45ms
[OK] /recipe/detail : 23ms
[SLOW] /recipe/search : 250ms   ← 要改善！
```

---

## 実装例5: メンテナンスモード

サイト全体を一時的にメンテナンス中にします。

### MaintenanceFilter.java

```java
package jp.co.recipe.filter;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.annotation.WebFilter;
import javax.servlet.http.HttpServletResponse;

@WebFilter("/*")
public class MaintenanceFilter implements Filter {

    // trueにするとメンテナンスモード
    private boolean maintenanceMode = false;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        // 設定ファイルから読み込むことも可能
        // maintenanceMode = Boolean.parseBoolean(filterConfig.getInitParameter("maintenance"));
    }

    @Override
    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
            throws IOException, ServletException {

        if (maintenanceMode) {
            // メンテナンス中のメッセージを表示
            HttpServletResponse response = (HttpServletResponse) res;
            response.setContentType("text/html; charset=UTF-8");
            PrintWriter out = response.getWriter();
            out.println("<!DOCTYPE html>");
            out.println("<html><head><title>メンテナンス中</title></head>");
            out.println("<body style='text-align:center; padding-top:100px;'>");
            out.println("<h1>メンテナンス中です</h1>");
            out.println("<p>しばらくお待ちください。</p>");
            out.println("</body></html>");
            // chain.doFilter()を呼ばない → サーブレットは実行されない
            return;
        }

        // 通常モード
        chain.doFilter(req, res);
    }

    @Override
    public void destroy() {
    }
}
```

---

## フィルターを使うべき場面まとめ

| 場面 | 説明 |
|------|------|
| **文字エンコーディング** | 全リクエストでUTF-8を設定 |
| **認証チェック** | ログインしていないユーザーをブロック |
| **アクセスログ** | 誰がいつどこにアクセスしたか記録 |
| **処理時間計測** | パフォーマンス監視 |
| **メンテナンスモード** | サイト全体を一時停止 |
| **CORS対応** | クロスオリジン設定 |
| **セキュリティヘッダー** | XSS対策などのヘッダー追加 |

---

## フィルターとリスナーの違い

| | フィルター | リスナー |
|---|-----------|---------|
| **実行タイミング** | リクエストごと | イベント発生時 |
| **主な用途** | リクエスト/レスポンスの加工 | 初期化、監視 |
| **例** | 認証、ログ、エンコーディング | DB接続、セッション数カウント |

```
【フィルター】毎回実行
リクエスト1 → Filter → Servlet
リクエスト2 → Filter → Servlet
リクエスト3 → Filter → Servlet

【リスナー】イベント時だけ
アプリ起動 → Listener実行
   ↓
（リクエスト1, 2, 3... Listenerは関係ない）
   ↓
アプリ終了 → Listener実行
```

---

## 複数フィルターの実行順序

`web.xml` で順序を指定できます。

```xml
<!-- web.xml -->
<filter>
    <filter-name>EncodingFilter</filter-name>
    <filter-class>jp.co.recipe.filter.EncodingFilter</filter-class>
</filter>
<filter>
    <filter-name>AuthFilter</filter-name>
    <filter-class>jp.co.recipe.filter.AuthFilter</filter-class>
</filter>

<!-- この順序で実行される -->
<filter-mapping>
    <filter-name>EncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
<filter-mapping>
    <filter-name>AuthFilter</filter-name>
    <url-pattern>/recipe/*</url-pattern>
</filter-mapping>
```

実行順序：
```
リクエスト → EncodingFilter → AuthFilter → Servlet
```

---

## ファイル配置

```
src/main/java/jp/co/recipe/
├── controller/          ← Servlet
├── dao/                 ← DAO
├── dto/                 ← DTO
├── filter/              ← フィルター
│   ├── EncodingFilter.java    ← 文字コード
│   ├── AuthFilter.java        ← 認証（任意）
│   └── AccessLogFilter.java   ← ログ（任意）
└── listener/            ← リスナー
```
